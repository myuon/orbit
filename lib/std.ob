let hp;

fun allocate_memory(size: int): [*]byte do
  let p = hp;
  hp = hp + size + 8; // +8 for size field

  let s = p as [*]int;
  s[0] = size;

  let b = p + 8;

  return b as [*]byte;
end

type slice(T: type) = struct {
  ptr: [*]T,
  len: int,

  fun get(self: slice(T), index: int): T do
    return self.ptr[index];
  end
} extends {
  .key = int,
  .value = T,
};

fun new_slice(size: int, len: int): slice(byte) do
  let pair = new slice(byte) { .ptr = allocate_memory(size * len), .len = len };

  return pair;
end

fun get_slice_int(data: slice(int), index: int): int do
  let ptr = data.ptr;
  return ptr[index];
end

fun get_slice_byte(data: slice(byte), index: int): byte do
  let ptr = data.ptr;
  return ptr[index];
end

fun new_vec(size: int, capacity: int): struct{ptr: [*]byte, len: int, capacity: int} do
  let vec = new struct{ptr: [*]byte, len: int, capacity: int} { .ptr = allocate_memory(size * capacity), .len = 0, .capacity = capacity };
  return vec;
end

fun get_vec_int(data: struct{ptr: [*]int, len: int, capacity: int}, index: int) do
  let ptr = data.ptr;
  return ptr[index];
end

fun set_vec_int(data: struct{ptr: [*]int, len: int, capacity: int}, index: int, value: int) do
  let ptr = data.ptr;
  ptr[index] = value;
  return 0;
end

fun push_vec_int(data: struct{ptr: [*]int, len: int, capacity: int}, value: int): int do
  if (data.len + 1 < data.capacity) do
    let ptr = data.ptr;
    ptr[data.len] = value;
    data.len = data.len + 1;
  else
    let new_data_byte = new_vec(sizeof int, data.capacity * 2);
    let new_data = new_data_byte as struct{ptr: [*]int, len: int, capacity: int};
    new_data.len = data.len;

    let i = 0;
    while (i < data.len) do
      set_vec_int(new_data, i, get_vec_int(data, i));
      i = i + 1;
    end

    push_vec_int(new_data, value);

    data.ptr = new_data.ptr;
    data.len = new_data.len;
    data.capacity = new_data.capacity;
  end

  return 0;
end
