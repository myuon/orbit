let hp;

fun allocate_memory(size: int): [*]byte do
  let p = hp;
  hp = hp + size + 8; // +8 for size field

  let s = p as [*]int;
  s[0] = size;

  let b = p + 8;

  return b as [*]byte;
end

type slice(T: type) = struct {
  ptr: [*]T,
  len: int,

  fun get(self: slice(T), index: int): T do
    return self.ptr[index];
  end

  fun set(self: slice(T), index: int, value: T) do
    self.ptr[index] = value;
  end

  fun _new(len: int) do
    let pair = new struct { ptr: [*]T, len: int } { .ptr = allocate_memory(sizeof T * len), .len = len };
    return pair as slice(T);
  end
} extends {
  .key = int,
  .value = T,
};

fun new_slice(T: type, len: int): slice(T) do
  let pair = new struct { ptr: [*]T, len: int } { .ptr = allocate_memory(sizeof T * len), .len = len };

  return pair as slice(T);
end

fun new_vec(T: type, capacity: int): struct{ptr: [*]T, len: int, capacity: int} do
  let vec = new struct{ptr: [*]T, len: int, capacity: int} { .ptr = allocate_memory(sizeof T * capacity) as [*]T, .len = 0, .capacity = capacity };

  return vec;
end

fun get_vec_int(data: struct{ptr: [*]int, len: int, capacity: int}, index: int) do
  let ptr = data.ptr;
  return ptr[index];
end

fun set_vec_int(data: struct{ptr: [*]int, len: int, capacity: int}, index: int, value: int) do
  let ptr = data.ptr;
  ptr[index] = value;
  return 0;
end

fun push_vec_int(data: struct{ptr: [*]int, len: int, capacity: int}, value: int): int do
  if (data.len + 1 < data.capacity) do
    let ptr = data.ptr;
    ptr[data.len] = value;
    data.len = data.len + 1;
  else
    let new_data = new_vec(type int, data.capacity * 2) as struct{ptr: [*]int, len: int, capacity: int};
    new_data.len = data.len;

    let i = 0;
    while (i < data.len) do
      set_vec_int(new_data, i, get_vec_int(data, i));
      i = i + 1;
    end

    push_vec_int(new_data, value);

    data.ptr = new_data.ptr;
    data.len = new_data.len;
    data.capacity = new_data.capacity;
  end

  return 0;
end
