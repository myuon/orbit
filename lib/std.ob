type array(T: type) = struct {
  data: [*]T,
  length: int,

  fun _new(length: int): array(T) do
    return new(struct) array(T) { .data = alloc(T, length), .length = length };
  end

  fun _new_from_data(data: [*]T, length: int): array(T) do
    return new(struct) array(T) { .data = data, .length = length };
  end

  fun _get(self: array(T), index: int): T do
    return self.data[index];
  end

  fun _set(self: array(T), index: int, value: T) do
    self.data[index] = value;
    return 0;
  end
};

type vec(T: type) = struct {
  data: [*]T,
  length: int,
  capacity: int,

  fun _new(): vec(T) do
    return new(struct) vec(T) { 
      .data = alloc(T, 4), 
      .length = 0, 
      .capacity = 4 
    };
  end

  fun _push(self: vec(T), item: T) do
    if (self.length >= self.capacity) do
      self.capacity = self.capacity * 2;
      let new_data = alloc(T, self.capacity);
      let i = 0;
      while (i < self.length) do
        new_data[i] = self.data[i];
        i = i + 1;
      end
      self.data = new_data;
    end

    self.data[self.length] = item;
    self.length = self.length + 1;
    return 0;
  end

  fun _get(self: vec(T), index: int): T do
    return self.data[index];
  end

  fun _set(self: vec(T), index: int, value: T) do
    self.data[index] = value;
    return 0;
  end
};

type map(K: type, V: type) = struct {
  data: [*]int,
  capacity: int,

  fun _new(): map(K, V) do
    let capacity = 128;
    let data = alloc(int, capacity * 3);
    
    let i = 0;
    while (i < capacity * 3) do
      data[i] = 0;
      i = i + 1;
    end
    
    return new(struct) map(K, V) { 
      .data = data, 
      .capacity = capacity
    };
  end

  fun _set(self: map(K, V), key: K, value: V): int do
    let hash = (key as int) % self.capacity;
    
    let i = 0;
    while (i < self.capacity) do
      let current_index = ((hash + i) % self.capacity) * 3;
      
      if self.data[current_index + 2] == 0 do
        self.data[current_index] = key as int;
        self.data[current_index + 1] = value as int;
        self.data[current_index + 2] = 1;
        return 0;
      end
      
      if self.data[current_index] == (key as int) do
        self.data[current_index + 1] = value as int;
        return 0;
      end
      
      i = i + 1;
    end
    
    return 0;
  end

  fun _get(self: map(K, V), key: K): V do
    let hash = (key as int) % self.capacity;
    
    let i = 0;
    while (i < self.capacity) do
      let current_index = ((hash + i) % self.capacity) * 3;
      
      if self.data[current_index + 2] == 0 do
        return 0 as V;
      end
      
      if self.data[current_index] == (key as int) do
        return self.data[current_index + 1] as V;
      end
      
      i = i + 1;
    end
    
    return 0 as V;
  end
};